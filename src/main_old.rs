use std::hint::black_box;

mod sys_alloc {
    #[cfg(windows)]
    mod windows {
        use std::{
            ffi::c_void,
            ptr::{null, null_mut, NonNull},
        };

        use windows_sys::Win32::System::Memory::{
            VirtualAlloc2, VirtualFree, MEM_COMMIT, MEM_DECOMMIT, MEM_RESERVE, PAGE_READWRITE,
        };

        #[must_use]
        pub fn reserve(size: usize) -> Option<NonNull<c_void>> {
            NonNull::new(unsafe {
                VirtualAlloc2(0, null(), size, MEM_RESERVE, PAGE_READWRITE, null_mut(), 0)
            })
        }

        #[must_use]
        pub unsafe fn commit(base: *mut c_void, size: usize) -> bool {
            !VirtualAlloc2(0, base, size, MEM_COMMIT, PAGE_READWRITE, null_mut(), 0).is_null()
        }

        #[must_use]
        pub unsafe fn uncommit(base: *mut c_void, size: usize) -> bool {
            VirtualFree(base, size, MEM_DECOMMIT) != 0
        }
    }

    #[cfg(windows)]
    pub use windows::*;
}

mod sys_read {
    #[cfg(all(windows, target_pointer_width = "64"))]
    mod windows_x64 {
        use std::arch::asm;
        use windows_sys::Win32::{
            Foundation::EXCEPTION_ACCESS_VIOLATION,
            System::{
                Diagnostics::Debug::{AddVectoredExceptionHandler, EXCEPTION_POINTERS},
                SystemServices::EXCEPTION_NONCONTINUABLE,
            },
        };

        // These are not available in windows_sys.
        const EXCEPTION_CONTINUE_SEARCH: i32 = 0x0;
        const EXCEPTION_CONTINUE_EXECUTION: i32 = -1i32;

        pub unsafe fn install_handler() {
            static CONTAINS_ZERO: u8 = 0;

            unsafe extern "system" fn handler(info: *mut EXCEPTION_POINTERS) -> i32 {
                let exception_info = &mut *(*info).ExceptionRecord;
                let context_info = &mut *(*info).ContextRecord;

                // Ensure that this exception was generated by `try_read`.
                if exception_info.ExceptionFlags & EXCEPTION_NONCONTINUABLE != 0 {
                    return EXCEPTION_CONTINUE_SEARCH;
                }

                if exception_info.ExceptionCode != EXCEPTION_ACCESS_VIOLATION {
                    return EXCEPTION_CONTINUE_SEARCH;
                }

                let accessed_addr = exception_info.ExceptionInformation[1];

                // TODO: Ensure that we're actually running in the context of a `read_from_heap` call.
                debug_assert_eq!(context_info.Rdx, accessed_addr as u64);

                // Replace the register value on stack and continue.
                context_info.Rdx = (&CONTAINS_ZERO as *const u8) as usize as u64;
                EXCEPTION_CONTINUE_EXECUTION
            }

            AddVectoredExceptionHandler(1, Some(handler));
        }

        pub unsafe fn read_from_heap(mut ptr: *const u8) -> u8 {
            let out: u8;
            asm! {
                "mov {out}, [rdx]",
                out = out(reg_byte) out,
                inout("rdx") ptr,
            }
            out
        }
    }

    #[cfg(all(windows, target_pointer_width = "64"))]
    pub use windows_x64::*;
}

fn main() {
    let full_size = dbg!(10usize.pow(9));
    let mut bytes = Vec::<u8>::with_capacity(full_size);
    for _ in 0..(bytes.capacity() / 2) {
        bytes.push(1);
    }
    println!("Done allocating.");

    black_box(&bytes);
    std::io::stdin().read_line(&mut String::new()).unwrap();

    black_box(&bytes);
    std::io::stdin().read_line(&mut String::new()).unwrap();
}
